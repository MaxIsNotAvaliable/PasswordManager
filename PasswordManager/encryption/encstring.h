#pragma once
#include <string>
#include <stdio.h>
#include <array>
#include <Windows.h>


#ifndef ENCSTRING_H
#define ENCSTRING_H

constexpr wchar_t __wkeys[] = {
	0x5941, 0x9412, 0x4120, 0x1207, 0x2076, 0x0762, 0x7620, 0x6207,
	0x2073, 0x0737, 0x7376, 0x3766, 0x766f, 0x66f6, 0x6f65, 0xf656,
	0x656d, 0x56d2, 0x6d20, 0xd207, 0x2070, 0x0706, 0x706f, 0x06f7,
	0x6f7a, 0xf7a6, 0x7a6e, 0xa6e6, 0x6e61, 0xe616, 0x616e, 0x16e6,
	0x6e69, 0xe696, 0x6969, 0x9692, 0x6920, 0x9206, 0x206e, 0x06e6,
	0x6e61, 0xe617, 0x6173, 0x1737, 0x7374, 0x3746, 0x746f, 0x46f6,
	0x6f6c, 0xf6c2, 0x6c27, 0xc276, 0x276b, 0x76b6, 0x6b6f, 0xb6f2,
	0x6f20, 0xf207, 0x2070, 0x0707, 0x7072, 0x0726, 0x7265, 0x2656,
	0x6569, 0x5697, 0x6973, 0x9737, 0x7370, 0x3706, 0x706f, 0x06f6,
	0x6f6c, 0xf6c6, 0x6c6e, 0xc6e6, 0x6e69, 0xe696, 0x696c, 0x96c7,
	0x6c73, 0xc737, 0x7379, 0x3796, 0x7961, 0x9612, 0x612c, 0x12c2,
	0x2c20, 0xc206, 0x2063, 0x0636, 0x6368, 0x3687, 0x6874, 0x8746,
	0x746f, 0x46f2, 0x6f20, 0xf207, 0x2079, 0x0796, 0x7961, 0x9612,
	0x6120, 0x1206, 0x206b, 0x06b6, 0x6b61, 0xb616, 0x616b, 0x16b2,
	0x6b20, 0xb206, 0x2062, 0x0627, 0x6275, 0x2756, 0x7564, 0x5647,
	0x6474, 0x4746, 0x746f, 0x46f2, 0x6f20, 0xf206, 0x2062, 0x0627,
	0x6279, 0x2792, 0x7920, 0x9207, 0x2075, 0x0757, 0x757a, 0x57a6,
	0x7a68, 0xa686, 0x6865, 0x8652, 0x6520, 0x5207, 0x2073, 0x0737,
	0x7374, 0x3746, 0x746f, 0x46f2, 0x6f20, 0xf207, 0x2074, 0x0747,
	0x7472, 0x4726, 0x7269, 0x2696, 0x696c, 0x96c6, 0x6c6c, 0xc6c6,
	0x6c69, 0xc696, 0x696f, 0x96f6, 0x6f6e, 0xf6e6, 0x6e6f, 0xe6f7,
	0x6f76, 0xf762, 0x7620, 0x6206, 0x206d, 0x06d6, 0x6d69, 0xd696,
	0x696c, 0x96c6, 0x6c6c, 0xc6c6, 0x6c69, 0xc696, 0x6961, 0x9617,
	0x6172, 0x1726, 0x7264, 0x2646, 0x646f, 0x46f7, 0x6f76, 0xf762,
	0x7620, 0x6206, 0x206c, 0x06c6, 0x6c65, 0xc657, 0x6574, 0x5742,
	0x7420, 0x4207, 0x2070, 0x0707, 0x7072, 0x0726, 0x726f, 0x26f7,
	0x6f7a, 0xf7a6, 0x7a68, 0xa686, 0x6869, 0x8697, 0x6976, 0x9766,
	0x7661, 0x6617, 0x6179, 0x1797, 0x7975, 0x9752, 0x7520, 0x5206,
	0x206e, 0x06e6, 0x6e61, 0xe612, 0x6120, 0x1207, 0x2074, 0x0747,
	0x7472, 0x4726, 0x7269, 0x2696, 0x696c, 0x96c6, 0x6c6c, 0xc6c6,
	0x6c69, 0xc696, 0x696f, 0x96f6, 0x6f6e, 0xf6e6, 0x6e61, 0xe616,
	0x6168, 0x1682, 0x6820, 0x8206, 0x2069, 0x0692, 0x6920, 0x9207,
	0x2074, 0x0747, 0x7472, 0x4726, 0x7269, 0x2696, 0x696c, 0x96c6,
	0x6c6c, 0xc6c6, 0x6c69, 0xc696, 0x696f, 0x96f6, 0x6f6e, 0xf6e6,
};

constexpr size_t __wkeysSz = sizeof(__wkeys) / sizeof(wchar_t);

constexpr char GetKey(size_t i)
{
	i = i % __wkeysSz;
	char b1 = HIBYTE(__wkeys[i]);
	char b2 = LOBYTE(__wkeys[i]);
	return b1 & b2;
}

template <size_t N>
constexpr std::array<char, N> str_encrypt(const char(&str)[N])
{
	std::array<char, N> output{};
	unsigned char x = 0, c = 0;

	for (int i = 0; i < N; ++i)
	{
		c = str[i];
		char k = GetKey(i);
		char t1 = (c ^ k);
		output[i] = t1;
	}
	return output;
}

template <size_t N>
constexpr std::string str_decrypt(const std::array<char, N>& str)
{
	std::string rc;
	unsigned char x = 0;
	for (size_t i = 0; i < str.size(); i++)
	{
		char c = str[i];
		char k = GetKey(i);
		char v = c ^ k;
		rc.push_back(v);
	}

	return rc;
}

#ifndef _DEBUG
/// <summary>
/// ѕри использовании следует передавать туда значени€ строк, которые определены до компил€ции, в ином случае можно использовать
/// такие методы, как: 
/// <para>str_encrypt()</para>
/// <para>str_decrypt()</para>
/// </summary>
/// <param name="str"> - массив элементов char, которые должны быть зашифрованы во врем€ компил€ции</param>
/// <returns><para>const char*</para> в расшифрованном виде</returns>
#define ENCSTR(str)										\
    ([]() {												\
        constexpr auto encrypted = str_encrypt(str);	\
        return str_decrypt(encrypted);					\
    }().c_str())

#define ENCSTR_STR(str)									\
    ([]() {												\
        constexpr auto encrypted = str_encrypt(str);	\
        return str_decrypt(encrypted);					\
    }())

#else
#define ENCSTR(str) (std::string(str).c_str())
#endif
/// <summary>
/// <para>≈сли нужен тип данных std::string - то можно использовать ENCSTR()</para><para>-</para>
/// ѕри использовании следует передавать туда значени€ строк, которые определены до компил€ции, в ином случае можно использовать
/// такие методы, как: 
/// <para>str_encrypt()</para>
/// <para>str_decrypt()</para>
/// </summary>
/// <param name="sz"> - массив элементов char, которые должны быть зашифрованы во врем€ компил€ции</param>
/// <returns><para>const char*</para> в расшифрованном виде</returns>
//#define ENCCCH(sz) (ENCSTR(sz).c_str())

#endif